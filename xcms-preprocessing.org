#+TITLE: Metabolomics data pre-processing using xcms
#+AUTHOR: Johannes Rainer
#+EMAIL: johannes.rainer@eurac.edu
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: header-args:R :exports code
#+PROPERTY: header-args:R :results silent
#+PROPERTY: header-args:R :session *Rmetabo*
#+STARTUP: overview

#+BEGIN_EXPORT html
---
title: "Metabolomics data pre-processing using xcms"
author: "Johannes Rainer (johannes.rainer@eurac.edu)\ngithub/twitter: jotsetung"
graphics: yes
date: "`r doc_date()`"
output:
  BiocStyle::html_document:
    number_sections: true
    toc_float: true
    toc_depth: 2
bibliography: references.bib
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

<!-- 
NOTE: this document should not be edited manually, as it will be over-written
by exporting the metabolomics-preprocessing.org file.
-->
#+END_EXPORT

* Background

This documents describes 
+ =xcms= a relatively /old/ package for untargeted, LC/GC-MS data preprocessing.
+ Major changes in =xcms= version > 3:
  - re-use data structures from Bioconductor's =MSnbase= package.
  - native MSn support.
  - New functions.
  - Internal changes and code cleanup.

** Mass spectrometry

Mass spectrometry allows to measure abundances of charged ions in a
sample. Abundances are determined as ion counts for a specific mass-to-charge
ration m/z. The measured signal is represented in a spectrum, intensities along
a m/z ratio.

#+BEGIN_EXPORT html
![](images/MS.png)
#+END_EXPORT

Many ions have the same or a very similar mass-to-charge ratio and MS is thus
frequently coupled with a second technology to separate the analytes based on
other properties than their charge (e.g. hydrophilic/hydrophobic. Common choices
are gas chromatography (GC) or liquid chromatography (LC). Such a e.g. LC-MS
setup performs thus scans at discrete time points resulting in a set of spectra
for a given sample, with compounds separated both on m/z and on retention time
dimension.

#+BEGIN_EXPORT html
![](images/LCMS.png)
#+END_EXPORT

In LC-MS data analysis ions are quantified by identifying and
integrating signal from /chromatographic/ peaks.

** Definitions and common naming convention

Below naming conventions and terms used throughout this document are listed:
+ chromatographic peak: peak containing the signal from an ion in retention time
  dimension.
+ chromatographic peak detection: process in which chromatographic peaks are
  identified within each file.
+ alignment: process that adjusts for retention time differences between files.
+ correspondence: grouping of chromatographic peaks (presumably from the same
  ion) across files.
+ feature: chromatographic peaks grouped across files.

* Workflow: metabolomics data preprocessing using =xcms=

This workflow describes the basic data handling (I/O) of mass spectrometry data
using the =MSnbase= package, and the LC/GC-MS data preprocessing using =xcms=. It
showcases the new functionality and user interface functions of =xcms=, that
re-use functionality from the =MSnbase= package. The first part of the workflow if
focused on data import, access and visualization followed by a short description
of a simple data centroiding approach and concluded by the =xcms=-based LC-MS data
preprocessing that comprises chromatographic peak detection, alignment and
correspondence. The workflow does not cover data normalization procedures,
compound identification and differential abundance analysis.

** Prerequisites

The analysis in this document requires an R version >= 3.5.0 and recent versions
of the =MSnbase= and =xcms= (version >= 3.3.1 is needed). The code below installs
all packages for the analysis.

#+NAME: install-required
#+BEGIN_SRC R :ravel eval = FALSE, results = "hide"
  source("https://bioconductor.org/biocLite.R")
  biocLite(c("xcms", "MSnbase", "doParallel", "msdata", "magrittr",
	     "devtools"))
  ## Need xcms version > 3.3.1
  if (packageVersion("xcms") < "3.3.1")
      devtools::install_github("sneumann/xcms", ref = "master")
#+END_SRC

** Data import and representation

Below we load all required libraries and read our toy data using the =readMSData=
function. The data set consists of subsets of two files in mzML format, with
pooled human serum samples measured with a ultra high performance liquid
chromatography (UHPLC) system (Agilent 1290) coupled with a Q-TOF MS (TripleTOF
5600+ AB Sciex). Chromatographic separation based on hydrophilic interaction
liquid chromatography (HILIC). The system was tuned to allow measurement of the
/polar metabolome/. We also define a =data.frame= describing the experiment and pass
this to the =readMSData=. We thus have all experiment-related information within
the same data object. The option =mode = "onDisk"= tells the function to read only
general metadata into memory. The m/z and intensity values from the original
files are not stored in memory, but retrieved from the original files on
demand. This enables the analysis also of very large experiments.

#+NAME: load-data
#+BEGIN_SRC R :ravel message = FALSE
  library(MSnbase)
  library(xcms)
  library(doParallel)
  library(magrittr)

  ## Define the file names.
  fls <- dir(system.file("sciex", package = "msdata"), full.names = TRUE)

  ## Define a data.frame with additional information on the files.
  pd <- data.frame(file = basename(fls),
		   injection_idx = c(1, 19),
		   sample = c("POOL_1", "POOL_2"),
		   group = "POOL")
  data <- readMSData(fls, pdata = new("NAnnotatedDataFrame", pd),
		     mode = "onDisk")
#+END_SRC

Next we set up the parallel processing. This ensures that all required cores are
registered and available from the beginning of the analysis. All data access and
analysis functions of =xcms= and =MSnbase= are parallelized on a per-file basis and
will use this setup by default.

#+NAME: parallel-setup
#+BEGIN_SRC R :ravel message = FALSE
  ## Set up parallel processing using 3 cores
  registerDoParallel(3)
  register(bpstart(DoparParam()), default = TRUE)
#+END_SRC

The experiment data is now represented as an =OnDiskMSnExp= object. Phenotype
information can be retrieved with the =pData= function, or directly using =$=. As
detailed above, only general information of each spectrum is stored in the
object enabling analyses also of very large experiments. Below we access sample
descriptions.

#+NAME: show-pData
#+BEGIN_SRC R :ravel message = FALSE
  ## Access phenotype information
  pData(data)

  ## Or individual columns directly using the $ operator
  data$injection_idx
#+END_SRC

The general information on each spectrum in the experiment can be accessed with
the =fData= function, that returns a =data.frame= with one row per spectrum.

#+NAME: show-fData
#+BEGIN_SRC R :ravel message = FALSE
  ## Access spectrum header information
  head(fData(data))
#+END_SRC

Note that, since the data is not kept in memory, any data manipulations (such as
spectrum smoothing) do not change the data, but are instead added to a lazy
evaluation queue and applied to the data on the fly, each time m/z or intensity
values are accessed.

** Basic data access and visualization

The MS data in an =OnDiskMSnExp= object is organized by spectrum (similar as in
/mzML/ files), with =Spectrum= objects used as containers for the respective m/z and
intensity values. General spectrum information can be retrieved using the
=msLevel=, =centroided=, =rtime= or =polarity= functions that return the respective
value for all spectra from all files. Here, the =fromFile= function can be helpful
to determine from which file/sample the respective spectrum information
comes. This is shown in the code block below.

#+NAME: general-access
#+BEGIN_SRC R :ravel message = FALSE
  ## Get the retention time
  head(rtime(data))

  ## Get the retention times splitted by file.
  rts <- split(rtime(data), fromFile(data))

  ## The result is a list of length 2. The number of spectra per file can
  ## then be determined with
  lengths(rts)
#+END_SRC

The =spectra= function can be used to retrieve the list of all spectra (from all
files). This will load the full data from all raw files (eventually applying
data manipulations stored in the lazy processing queue), which can take,
depending on the size of the experiment, a relatively long time. In most cases
we will however work anyway with sub-sets of the data, and retrieving such data
can be, in the case of indexed mzML, mzXML and CDF files, very fast. Data
objects can be easily subsetted using the filter functions: =filterFile=,
=filterRtime=, =filterMz= or =filterMsLevel= that filter the data by file, retention
time range, m/z range or MS level. To illustrate this we retrieve below all
spectra measured between 180 and 181 seconds. Note that we use the pipe operator
=%>%= from the =magrittr= package to avoid nested function calls.

#+NAME: spectra-filterRt
#+BEGIN_SRC R :ravel message = FALSE
  ## Get all spectra measured between 180 and 181 seconds
  ## Use %>% for better readability
  sps <- data %>%
      filterRt(rt = c(180, 181)) %>%
      spectra
#+END_SRC

The result is a =list= of =Spectrum= objects. Below we determine the number of
spectra we've got.

#+NAME: spectra-filterRt-length
#+BEGIN_SRC R :ravel message = FALSE
  ## How many spectra?
  length(sps)
#+END_SRC

We can use the =fromFile= function to determine from which file/sample each
spectrum is.

#+NAME: spectra-filterRt-fromFile
#+BEGIN_SRC R :ravel message = FALSE
  ## From which file?
  sapply(sps, fromFile)
#+END_SRC

We have thus 3 spectra per file. Below we plot the data from the last spectrum
(i.e. the 3rd spectrum in the present retention time window from the second
file).

#+NAME: spectrum-plot
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Spectrum at a retention time of about 180 seconds."
  plot(sps[[6]])
#+END_SRC

We can immediately spot several mass peaks in the spectrum, with the largest one
at a m/z of about 130 and the second largest at about 106, which matches the
expected mass to charge ratio for the [M+H]+ adduct of Serine. 

MS data is in general organized by spectrum, but in LC-MS experiments we analyze
the data along the retention time axis and hence orthogonally to the data
representation in a spectrum. We can use the =chromatogram= function to extract
such data. The function aggregates intensities for each scan/retention time
along the m/z axis (i.e. within each spectrum) and returns the retention time -
intensity duplets in a =Chromatogram= object, one per file. The =Chromatogram=
object supports, similar to the =Spectrum= object, the =rtime= and =intensity=
functions to extract the respective information. Below we use the =chromatogram=
function to extract the total ion chromatogram (TIC) for each file and plot it.

#+NAME: chromatogram-tic
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Total ion chromatogram.", fig.width = 10, fig.height = 5
  ## Get chromatographic data (TIC) for an m/z slice
  chr <- chromatogram(data)
  chr

  ## Plot the tic
  plot(chr)
#+END_SRC

The object returned by the =chromatogram= function arranges the individual
=Chromatogram= objects of each file in a two-dimensional array, columns being
samples (files) and rows data slices. Below we extract the (total ion)
intensities from the TIC of the first file.

#+NAME: chromatogram-tic-intensity
#+BEGIN_SRC R :ravel message = FALSE
  ints <- intensity(chr[1, 1])
  head(ints)
#+END_SRC

The object contains also the phenotype information from the original =data=
variable, that can be accessed similarly to the =OnDiskMSnExp= object (or most
other data objects in Bioconductor).

#+NAME: chromatogram-pdata
#+BEGIN_SRC R :ravel message = FALSE
  ## Access the full phenotype data
  pData(chr)
#+END_SRC

Depending on the parameter =aggregationFun=, the function can produce total ion
chromatograms (TIC), with =aggregationFun = "sum"= or base peak chromatograms
(BPC) with =aggregationFun = "max"=. Below we extract and plot the ion
chromatogram for Serine after first filtering the data object by retention time
and by m/z.

#+NAME: serine-xic
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Extracted ion chromatogram for the Serine [M+H]+ ion in both files."
  ## Extract and plot the XIC for Serine
  data %>%
      filterRt(rt = c(175, 189)) %>%
      filterMz(mz = c(106.02, 106.07)) %>%
      chromatogram(aggregationFun = "max") %>%
      plot()
#+END_SRC 


** Centroiding of profile MS data

MS instruments allow to export data in profile or centroid mode. Profile data
contains the signal for all discrete m/z values (and retention times) for which
the instrument collected data \cite{Smith:2014di}. For each ion at a given
retention time the instrument measures thus multiple intensities, at m/z values
that are distributed around the ion's m/z value. Centroiding is the process to
reduce these mass peaks to a single representative signal, the centroid. =xcms=,
specifically the /centWave/ chromatographic peak detection algorithm, was designed
for centroided data, thus, prior to data analysis, profile data should be
centroided. The =MSnbase= package provides the basic toolset to perform
centroiding (and data smoothing): =pickPeaks= and =smooth=. 

Below we inspect the profile data for the [M+H]+ ion adduct of Serine. We subset
the data to the m/z and retention time range containing signal from Serine and
=plot= the data with =type = "XIC"=, that generates a combined chromatographic and
/map/ visualization of the data (i.e. a plot of the individual m/z, rt and
intensity data tuples with the data points shown in the m/z - retention time
space with intensity-dependent coloring).

#+NAME: serine-profile-mode-data
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Profile data for Serine.", fig.width = 10, fig.height = 5, fig.pos = "h!", warning = FALSE
  ## Filter the MS data to the signal from the Serine ion and plot it using
  ## type = "XIC"
  data %>%
      filterRt(rt = c(175, 189)) %>%
      filterMz(mz = c(106.02, 106.07)) %>%
      plot(type = "XIC")
#+END_SRC

The plot shows all registered and exported data points from the instrument. The
plot above clearly shows the mass peaks for Serine, that are represented by a
distribution of signal in both retention time and m/z dimension.

Next we first smooth the data per spectrum using a Savitzky-Golay filter, which
usually improves data quality by reducing noise, followed by centroiding the
data with a simple peak-picking strategy that reports the maximum signal for
each mass peak in each spectrum.

#+NAME: centroiding
#+BEGIN_SRC R :ravel message = FALSE, warning = FALSE, fig.cap = "Centroided data for Serine.", fig.width = 10, fig.height = 5, fig.pos = "h!", warning = FALSE
  ## Smooth the signal, then do a simple peak picking.
  data_cent <- data %>%
      smooth(method = "SavitzkyGolay", halfWindowSize = 6) %>%
      pickPeaks()

  ## Plot the centroided data for Serine
  data_cent %>%
      filterRt(rt = c(175, 189)) %>%
      filterMz(mz = c(106.02, 106.07)) %>%
      plot(type = "XIC")
#+END_SRC

As expected, centroiding successfully reduced the data to a single data point
for an ion in each spectrum. For more advanced centroiding options that also
fine-tune the m/z value of the reported centroid see the =pickPeaks= help or the
centroiding vignette in =MSnbase=.

Note that, since the MS data is not loaded in memory, smoothing and centroiding
is applied to the data /on-the-fly/ each time that m/z or intensity values are
requested from the data object =data_cent=. To make any data manipulations on an
=OnDiskMSnExp= object /persistent/ we need to export the data. Below we save thus
the centroided data as mzML files and read the exported data again.

#+NAME: export-centroided-prepare
#+BEGIN_SRC R :ravel message = FALSE, echo = FALSE, warnings = FALSE, results = "hide"
  ## Silently removing exported mzML files if they do already exist.
  lapply(basename(fileNames(data)), function (z) {
      if (file.exists(z))
	  file.remove(z)
  })
#+END_SRC

#+NAME: export-centroided
#+BEGIN_SRC R :ravel message = FALSE
  ## Write the centroided data to files with the same names in the current
  ## directory
  fls_new <- basename(fileNames(data))
  writeMSData(data_cent, file = fls_new)

  ## Read the centroided data.
  data_cent <- readMSData(fls_new, pdata = new("NAnnotatedDataFrame", pd),
			  mode = "onDisk")
#+END_SRC

** LC-MS data preprocessing

*** Chromatographic peak detection

+ Aim: identify chromatographic peaks in the data.
+ Function: =findChromPeaks=.
+ Available methods:
  - /matchedFilter/ (=MatchedFilterParam=) \cite{Smith:2006ic}.
  - /centWave/ (=CentWaveParam=) \cite{Tautenhahn:2008fx}.
  - /massifquant/ (=MassifquantParam=) \cite{Conley:2014ha}.

+ CentWave is a two-step approach:
1) identify regions of interest.

#+BEGIN_EXPORT html
![](images/centWave-ROI.png)
#+END_EXPORT

2) peak detection within this regions using continuous wavelet transform (CWT).

#+BEGIN_EXPORT html
![](images/centWave-CWT.png)
#+END_EXPORT

+ CentWave parameters:

#+NAME: centwave-help
#+BEGIN_SRC R :ravel results = "hide"
  ?CentWaveParam
#+END_SRC

+ Crucial parameters: =peakwidth=, =ppm=.
+ =peakwidth=: minimal and maximal expected peak width. Depends on the LC
  settings of the experiment.
+ Interactive code: extract chromatographic data for Serine and perform peak
  detection using default parameters

#+NAME: centWave-default
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "XIC for Serine", results = "hide"
  ## Get the XIC for serine in the first file
  srn_chr <- chromatogram(data_cent, rt = c(165, 200),
			  mz = c(106.03, 106.06),
			  aggregationFun = "max")[1, 1]
  ## Plot the data
  par(mfrow = c(1, 1), mar = c(4, 4.5, 1, 1))
  plot(srn_chr)

  ## Get default centWave parameters
  cwp <- CentWaveParam()

  ## "dry-run" peak detection on the XIC.
  findChromPeaks(srn_chr, param = cwp)

  cwp
#+END_SRC

+ What went wrong? Default for =peakwidth= does not match the current data.
+ Interactive code: change =peakwidth= and run again.

#+NAME: centWave-adapted
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "XIC for Serine with detected chromatographic peak", results = "hide"
  cwp <- CentWaveParam(peakwidth = c(2, 10))

  pks <- findChromPeaks(srn_chr, param = cwp)

  ## Plot the data and higlight identified peak area
  plot(srn_chr)
  rect(pks[, "rtmin"], 0, pks[, "rtmax"], pks[, "maxo"], border = "#00000040")
#+END_SRC

+ Ideally check settings on more known compounds.
+ =ppm=: maximal allowed scattering of m/z values for one ion.
+ Interactive code: evaluate the m/z scattering of the signal for Serine.

#+NAME: Serine-mz-scattering-plot
#+BEGIN_SRC R :ravel message = FALSE
  ## Restrict the data to signal from Sering
  srn <- data_cent %>%
      filterRt(rt = c(179, 186)) %>%
      filterMz(mz = c(106.04, 106.06))

  ## Plot the data
  plot(srn, type = "XIC")
#+END_SRC

+ Interactive code: calculate the difference in m/z values between consecutive
  scans.

#+NAME: define-ppm
#+BEGIN_SRC R :ravel message = FALSE
  ## Extract the Serine data for one file as a data.frame
  srn_df <- as(filterFile(srn, 1), "data.frame")
  head(srn_df)

  ## The difference between m/z values from consecutive scans
  diff(srn_df$mz)

  ## The same in ppm
  diff(srn_df$mz) * 1e6 / mean(srn_df$mz)
#+END_SRC

+ Ideally this should also be performed on more compounds.
+ =ppm= should be large enough to capture the full chromatographic peak.
+ Interactive code: perform chromatographic peak detection.

#+NAME: findPeaks-centWave
#+BEGIN_SRC R :ravel message = FALSE
  ## Perform peak detection
  cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 30)
  data_cent <- findChromPeaks(data_cent, param = cwp)
#+END_SRC

+ Result: =XCMSnExp= object extends the =OnDiskMSnExp=, so we can access the data in
  the same way plus it stores preprocessing results.
+ Interactive code: explore the result object.

#+NAME: xcmsnexp
#+BEGIN_SRC R :ravel message = FALSE, results = "hide"
  data_cent

  ## Access the peak detection results
  head(chromPeaks(data_cent))
#+END_SRC

+ For quality assessment, we could also do some summary statistics on the
  identified peaks.
+ Interactive code: plot the location of the identified peaks in the m/z - rt
  plane.
#+NAME: plotChromPeaks
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Location of the identified chromatographic peaks"
  par(mfrow = c(1, 2))
  plotChromPeaks(data_cent, 1)
  plotChromPeaks(data_cent, 2)
#+END_SRC

*** Alignment

+ Aim: adjusts shifts in retention times between samples.
+ Interactive code: plot the base peak chromatograms of all files.
#+NAME: alignment-bpc-raw
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "BPC of all files", fig.width = 8, fig.height = 4
  ## Extract base peak chromatograms
  bpc_raw <- chromatogram(data_cent, aggregationFun = "max")
  par(mfrow = c(1, 1))
  plot(bpc_raw)
#+END_SRC

+ Function: =adjustRtime=.
+ Available methods:
  - /peakGroups/ (=PeakGroupsParam=) \cite{Smith:2006ic}: align samples based on
    hook peaks.
  - /obiwarp/ (=ObiwarpParam=) \cite{Prince:2006jj}: warps the (full) data to a
    reference sample.

+ peakGroups works reasonably well in most cases.
+ Need to define the hook peaks first: peaks present in most/all samples.
+ Important parameters:
  - =minFraction=: proportion of samples in which a feature has to be present (0.9
    for present in 90% of samples).
  - =span=: degree of smoothing for the loess function, 0 likely overfitting, 1
    linear regression. Values between 0.4 and 0.6 seem reasonable.
+ Interactive code: perform a peak grouping to define potential hook peaks and
  align the samples based on these.
#+NAME: alignment-correspondence
#+BEGIN_SRC R :ravel message = FALSE
  ## Define the settings for the initial peak grouping - details for
  ## choices in the next section.
  pdp <- PeakDensityParam(sampleGroups = data_cent$group, bw = 1.8,
			  minFraction = 1, binSize = 0.02)
  data_cent <- groupChromPeaks(data_cent, pdp)

  ## Define settings for the alignment
  pgp <- PeakGroupsParam(minFraction = 1, span = 0.6)
  data_cent <- adjustRtime(data_cent, param = pgp)
#+END_SRC

+ Adjusted retention times are stored in the object.
+ Interactive code: inspect the difference between raw and adjusted retention
  times. Helps to determine whether settings were OK.
#+NAME: alignment-result
#+BEGIN_SRC R :ravel message = FALSE, fig.width = 8, fig.height = 4
  ## Plot the difference between raw and adjusted retention times
  plotAdjustedRtime(data_cent)
#+END_SRC

+ Evaluate alignment results:
  - difference between raw and adjusted retention time reasonable.
  - hook peaks along the full retention time range.
  - comparison of BPC (TIC) before/after alignment.
  - evaluate data for known compounds.
+ Interactive code: plot BPC before and after alignment.

#+NAME: bpc-raw-adjusted
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "BPC before (top) and after (bottom) alignment.", fig.width = 10, fig.height = 8
  par(mfrow = c(2, 1))
  ## Plot the raw base peak chromatogram
  plot(bpc_raw)
  ## Plot the BPC after alignment
  plot(chromatogram(data_cent, aggregationFun = "max"))
#+END_SRC

+ Interactive code: plot Serine XIC before and after alignment.

#+NAME: serine-xic-adjusted
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "XIC for Serine before (left) and after (right) alignment", fig.width = 10, fig.height = 4
  ## Use adjustedRtime parameter to access raw/adjusted retention times
  par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
  plot(chromatogram(data_cent, mz = c(106.04, 106.06),
		    rt = c(179, 186), adjustedRtime = FALSE))
  plot(chromatogram(data_cent, mz = c(106.04, 106.06),
		    rt = c(179, 186)))
#+END_SRC

+ If we need to repeat simply remove alignment results with =dropAdjustedRtime=
  and retry.

*** Correspondence

+ Aim: group signal (peaks) from the same ion across samples.
+ Function: =groupChromPeaks=.
+ Methods available:
  - /peak density/ (=PeakDensityParam=) \cite{Smith:2006ic}.
  - /nearest/ (=NearestPeaksParam=) \cite{Katajamaa:2006jh}.

+ peak density: 
  - iterates through slices of m/z ranges and groups chromatographic in each if
    peaks (from same or different samples) are close in retention time.
  - whether they are close is estimated on the distribution of peaks along the
    retention time.
+ Interactive code: plot the data for the m/z slice containing the Serine peak
  and dry-run a correspondence analysis.

#+NAME: correspondence-example
#+BEGIN_SRC R :ravel message = FALSE, results = "hide", fig.cap = "BPC for a m/z slice and defined features within this slice based on default settings." 
  ## Plot the BPC for the m/z slice containing serine
  par(mfrow = c(2, 1), mar = c(4, 4.3, 1, 0.5))
  plot(chromatogram(data_cent, mz = c(106.04, 106.06), aggregationFun = "max"))
  highlightChromPeaks(data_cent, mz = c(106.04, 106.06),
		      whichPeaks = "apex_within")

  ## Get default parameters for the grouping
  pdp <- PeakDensityParam(sampleGroups = data_cent$group)
  pdp

  ## Dry-run correspondence and show the results.
  plotChromPeakDensity(data_cent, mz = c(106.04, 106.06),
		       type = "apex_within", param = pdp)

#+END_SRC

+ Black line shows the peak density estimate, points represent the position of
  peaks along the retention time axis per sample and grey rectangles indicate
  grouped peaks (features).
+ Parameters:
  - =binSize=: m/z width of the bin/slice of data in which peaks are grouped.
  - =bw= defines the smoothness of the density function.
  - =maxFeatures=: maximum number of features to be defined in one bin.
  - =minFraction=: minimum proportion of samples (of one group!) for which a peak
    has to be present.
  - =minSamples=: minimum number of samples a peak has to be present.
+ Parameters =minFraction= and =minSamples= depend on experimental layout!
+ =binSize= should be small enough that peaks from different ions measured at the
  same retention time would not be grouped together.
+ Interactive code: determine acceptable =bw= setting. Plot data for ions with
  same m/z and similar retention time: isomers Betaine and Valine ([M+H]+ m/z
  118.08625).

#+NAME: correspondence-bw
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Define correspondence settings to separate Methylhistidine peaks.", fig.width = 10, fig.height = 10
  par(mfrow = c(3, 1), mar = c(3, 4.3, 1, 1))

  ## Plot the chromatogram for an m/z slice containing Betaine and Valine
  mzr <- 118.08625 + c(-0.01, 0.01)
  plot(chromatogram(data_cent, mz = mzr, aggregationFun = "max"))
  highlightChromPeaks(data_cent, mz = mzr, whichPeaks = "apex_within")

  ## Correspondence in that slice using default settings
  pdp <- PeakDensityParam(sampleGroups = data_cent$group)
  plotChromPeakDensity(data_cent, mz = mzr, param = pdp, type = "apex_within")

  ## Reducing the bandwidth
  pdp <- PeakDensityParam(sampleGroups = data_cent$group, bw = 1.8)
  plotChromPeakDensity(data_cent, mz = mzr, param = pdp, type = "apex_within")
#+END_SRC

+ Reducing the =bw= enables grouping of isomer peaks into different
  features.
+ Interactive code: perform the correspondence analysis.

#+NAME: correspondence-analysis
#+BEGIN_SRC R :ravel message = FALSE
  pdp <- PeakDensityParam(sampleGroups = data_cent$group, bw = 1.8,
			  minFraction = 0.4, binSize = 0.02)

  ## Perform the correspondence analysis
  data_cent <- groupChromPeaks(data_cent, param = pdp)
#+END_SRC

+ Evaluate results after correspondence: check for another slice with isomers:
  Leucine, Isoleucine ([M+H]+ m/z 132.10191). Setting =simulate = FALSE= shows the
  actual grouping results.

#+NAME: correspondence-evaluate
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Result of correspondence on a slice containing the isomers Leucine and Isoleucine.", fig.width = 10, fig.heigt = 8
  par(mfrow = c(2, 1), mar = c(3, 4.3, 1, 1))

  ## Plot the chromatogram for an m/z slice containing Leucine and Isoleucine
  mzr <- 132.10191 + c(-0.01, 0.01)
  plot(chromatogram(data_cent, mz = mzr, aggregationFun = "max"))
  highlightChromPeaks(data_cent, mz = mzr, whichPeaks = "apex_within")

  plotChromPeakDensity(data_cent, mz = mzr, param = pdp, type = "apex_within",
		       simulate = FALSE)
#+END_SRC

+ Interactive code: inspect result object and extract feature intensities.

#+NAME: correspondence-result-object
#+BEGIN_SRC R :ravel message = FALSE
  ## Get general information
  data_cent

  ## Overview of the performed processings
  processHistory(data_cent)

  ## Access the parameter class for a processing step
  processParam(processHistory(data_cent)[[1]])
#+END_SRC

+ Interactive code: inspect definition of features and extract feature
intensities.

#+NAME: correspondence-feature-values
#+BEGIN_SRC R :ravel message = FALSE
  ## Definition of the features
  featureDefinitions(data_cent)

  ## Per-feature summary.
  head(featureSummary(data_cent))

  ## feature intensity matrix
  fmat <- featureValues(data_cent, value = "into", method = "maxint")
  head(fmat)
#+END_SRC

+ =featureValues= parameters:
  - =value=: name of the column in =chromPeaks= that should be returned.
  - =method=: for features with multiple peaks in one sample: from which peak the
    should the value be returned?

+ About missing values: peak detection may have failed. =fillChromPeaks= allows to
  fill in signal for missing peaks from the feature area (defined by the median
  rt and mz of all peaks assigned to the feature).
  Parameters:
  - =expandMz=: expands the region from which signal is integrated in m/z
    dimension. A value of 0 means no expansion, 1 means the region is grown by
    half of the feature's m/z width on both sides.
  - =expandRt=: expand the retention time window of the feature for integration.
  - =ppm=: expand the m/z width by a m/z dependent value.
+ Interactive code: evaluate the number of missing peaks and use =fillChromPeaks=
  to retrieve a signal for them from the raw files.

#+NAME: fillChromPeaks
#+BEGIN_SRC R :ravel message = FALSE
  ## Number of missing values
  sum(is.na(fmat))

  ## Define the settings for the fill-in of missing peaks
  fpp <- FillChromPeaksParam(expandMz = 0.5, expandRt = 0.5, ppm = 20)
  data_cent <- fillChromPeaks(data_cent, param = fpp)

  ## How many missing values after
  sum(is.na(featureValues(data_cent)))

  fmat_fld <- featureValues(data_cent, value = "into", method = "maxint")
  head(fmat_fld)
#+END_SRC

+ Note: =dropFilledChromPeaks= removes filled-in peaks again.

* Summary

+ Don't blindly use default parameters!
+ The new data objects and functions are aimed to simplify data access and
  inspection of results and should facilitate data set-dependent definition of
  algorithm parameters.
+ More work to come for the analysis of chromatographic data (SRM/MRM).

* References






