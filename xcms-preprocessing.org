#+TITLE: Metabolomics data pre-processing using xcms
#+AUTHOR: Johannes Rainer
#+EMAIL: johannes.rainer@eurac.edu
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: header-args:R :exports code
#+PROPERTY: header-args:R :results silent
#+PROPERTY: header-args:R :session *Rmetabo*
#+STARTUP: overview

#+BEGIN_EXPORT html
---
title: "Metabolomics data pre-processing using xcms"
author: "Johannes Rainer (johannes.rainer@eurac.edu)\ngithub/twitter: jotsetung"
graphics: yes
date: "`r doc_date()`"
output:
  BiocStyle::html_document:
    number_sections: true
    toc_float: true
    toc_depth: 2
bibliography: references.bib
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

<!-- 
NOTE: this document should not be edited manually, as it will be over-written
by exporting the metabolomics-preprocessing.org file.
-->
#+END_EXPORT

* Background

This documents describes 
+ =xcms= a relatively /old/ package for untargeted, LC/GC-MS data preprocessing.
+ Major changes in =xcms= version > 3:
  - re-use data structures from Bioconductor's =MSnbase= package.
  - native MSn support.
  - New functions.
  - Internal changes and code cleanup.

** Mass spectrometry

Mass spectrometry allows to measure abundances of charged ions in a
sample. Abundances are determined as ion counts for a specific mass-to-charge
ration m/z. The measured signal is represented in a spectrum, intensities along
a m/z ratio.

#+BEGIN_EXPORT html
![](images/MS.png)
#+END_EXPORT

Many ions have the same or a very similar mass-to-charge ratio and MS is thus
frequently coupled with a second technology to separate the analytes based on
other properties than their charge (e.g. hydrophilic/hydrophobic. Common choices
are gas chromatography (GC) or liquid chromatography (LC). Such a e.g. LC-MS
setup performs thus scans at discrete time points resulting in a set of spectra
for a given sample, with compounds separated both on m/z and on retention time
dimension.

#+BEGIN_EXPORT html
![](images/LCMS.png)
#+END_EXPORT

In LC-MS data analysis ions are quantified by identifying and
integrating signal from /chromatographic/ peaks.

** Definitions and common naming convention

Below naming conventions and terms used throughout this document are listed:
+ chromatographic peak: peak containing the signal from an ion in retention time
  dimension.
+ chromatographic peak detection: process in which chromatographic peaks are
  identified within each file.
+ alignment: process that adjusts for retention time differences between files.
+ correspondence: grouping of chromatographic peaks (presumably from the same
  ion) across files.
+ feature: chromatographic peaks grouped across files.

* Workflow: metabolomics data preprocessing using =xcms=

This workflow describes the basic data handling (I/O) of mass spectrometry data
using the =MSnbase= package, and the LC/GC-MS data preprocessing using =xcms=. It
showcases the new functionality and user interface functions of =xcms=, that
re-use functionality from the =MSnbase= package. The first part of the workflow is
focused on data import, access and visualization followed the description of a
simple data centroiding approach and concluded by the =xcms=-based LC-MS data
preprocessing that comprises chromatographic peak detection, alignment and
correspondence. The workflow does not cover data normalization procedures,
compound identification and differential abundance analysis.

** Prerequisites

The analysis in this document requires an R version >= 3.5.0 and recent versions
of the =MSnbase= and =xcms= (version >= 3.3.1 is needed). The code below installs
all packages for the analysis.

#+NAME: install-required
#+BEGIN_SRC R :ravel eval = FALSE, results = "hide"
  source("https://bioconductor.org/biocLite.R")
  biocLite(c("xcms", "MSnbase", "doParallel", "msdata", "magrittr",
	     "devtools"))
  ## Need xcms version > 3.3.1
  if (packageVersion("xcms") < "3.3.1")
      devtools::install_github("sneumann/xcms", ref = "master")
#+END_SRC

** Data import and representation

Below we load all required libraries and read our toy data using the =readMSData=
function. This data set consists of two files in mzML format, with signals from
pooled human serum samples measured with a ultra high performance liquid
chromatography (UHPLC) system (Agilent 1290) coupled with a Q-TOF MS (TripleTOF
5600+ AB Sciex). Chromatographic separation based on hydrophilic interaction
liquid chromatography (HILIC). The system was tuned to allow measurement of the
/polar metabolome/. To reduce file sizes, the data set was restricted to an m/z
range from 105 to 134 and retention times from 0 to 260 seconds. We also define
a =data.frame= describing the experiment and pass this to the =readMSData=
function. We thus have all experiment-related information within the same data
object. The option =mode = "onDisk"= tells the function to read only general
metadata into memory. The m/z and intensity values from the original files are
not kept in memory, but retrieved from the original files on demand. This
enables analyses of very large experiments.

#+NAME: load-data
#+BEGIN_SRC R :ravel message = FALSE
  library(MSnbase)
  library(xcms)
  library(doParallel)
  library(magrittr)

  ## Define the file names.
  fls <- dir(system.file("sciex", package = "msdata"), full.names = TRUE)

  ## Define a data.frame with additional information on the files.
  pd <- data.frame(file = basename(fls),
		   injection_idx = c(1, 19),
		   sample = c("POOL_1", "POOL_2"),
		   group = "POOL")
  data <- readMSData(fls, pdata = new("NAnnotatedDataFrame", pd),
		     mode = "onDisk")
#+END_SRC

Next we set up the parallel processing. This ensures that all required cores are
registered and available from the beginning of the analysis. All data access and
analysis functions of =xcms= and =MSnbase= are parallelized on a per-file basis and
will use this setup by default.

#+NAME: parallel-setup
#+BEGIN_SRC R :ravel message = FALSE
  ## Set up parallel processing using 3 cores
  registerDoParallel(3)
  register(bpstart(DoparParam()), default = TRUE)
#+END_SRC

The experiment data is now represented as an =OnDiskMSnExp= object. Phenotype
information can be retrieved with the =pData= function, or directly using =$=. Below
we access sample descriptions.

#+NAME: show-pData
#+BEGIN_SRC R :ravel message = FALSE
  ## Access phenotype information
  pData(data)

  ## Or individual columns directly using the $ operator
  data$injection_idx
#+END_SRC

The general information on each spectrum in the experiment can be accessed with
the =fData= function, that returns a =data.frame= with one row per spectrum.

#+NAME: show-fData
#+BEGIN_SRC R :ravel message = FALSE
  ## Access spectrum header information
  head(fData(data))
#+END_SRC

Note that, since the data is not kept in memory, any data manipulations (such as
spectrum smoothing) do not actually change the data, but are applied to the data
on the fly (i.e. each time m/z or intensity values are accessed).

** Basic data access and visualization

The MS data in an =OnDiskMSnExp= object is organized by spectrum (similar as in
/mzML/ files), with =Spectrum= objects used as containers for the m/z and intensity
values. General spectrum information can be retrieved using the =msLevel=,
=centroided=, =rtime= or =polarity= functions that return the respective value for all
spectra from all files. Here, the =fromFile= function can be helpful to determine
from which file/sample the information comes. This is shown in the code block
below.

#+NAME: general-access
#+BEGIN_SRC R :ravel message = FALSE
  ## Get the retention time
  head(rtime(data))

  ## Get the retention times splitted by file.
  rts <- split(rtime(data), fromFile(data))

  ## The result is a list of length 2. The number of spectra per file can
  ## then be determined with
  lengths(rts)
#+END_SRC

The =spectra= function can be used to retrieve the list of all spectra (from all
files). This will load the full data from all raw files (eventually applying
data manipulations stored in the lazy processing queue), which can take,
depending on the size of the experiment, a relatively long time. In most cases
we will however work anyway with sub-sets of the data, and retrieving such data
can, in the case of indexed mzML, mzXML and CDF files, be very fast. Data
objects can be easily subsetted using the filter functions: =filterFile=,
=filterRtime=, =filterMz= or =filterMsLevel= that filter the data by file, retention
time range, m/z range or MS level. To illustrate this we retrieve below all
spectra measured between 180 and 181 seconds. Note that we use the pipe operator
=%>%= from the =magrittr= package for better readability by avoiding nested function
calls.

#+NAME: spectra-filterRt
#+BEGIN_SRC R :ravel message = FALSE
  ## Get all spectra measured between 180 and 181 seconds
  ## Use %>% for better readability
  sps <- data %>%
      filterRt(rt = c(180, 181)) %>%
      spectra
#+END_SRC

The result is a =list= of =Spectrum= objects. Below we determine the number of
spectra we've got.

#+NAME: spectra-filterRt-length
#+BEGIN_SRC R :ravel message = FALSE
  ## How many spectra?
  length(sps)
#+END_SRC

We can use the =fromFile= function to determine from which file/sample each
spectrum is.

#+NAME: spectra-filterRt-fromFile
#+BEGIN_SRC R :ravel message = FALSE
  ## From which file?
  sapply(sps, fromFile)
#+END_SRC

We have thus 3 spectra per file. Next we plot the data from the last spectrum
(i.e. the 3rd spectrum in the present retention time window from the second
file).

#+NAME: spectrum-plot
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Spectrum at a retention time of about 180 seconds."
  plot(sps[[6]])
#+END_SRC

We can immediately spot several mass peaks in the spectrum, with the largest one
at a m/z of about 130 and the second largest at about 106, which matches the
expected mass to charge ratio for the [M+H]+ adduct of Serine.

MS data is in general organized by spectrum, but in LC-MS experiments we analyze
the data along the retention time axis and hence orthogonally to this data
representation. We can however use the =chromatogram= function to extract such
data. The function aggregates intensities for each scan/retention time along the
m/z axis (i.e. within each spectrum) and returns the retention time - intensity
duplets in a =Chromatogram= object, one per file. The =Chromatogram= object
supports, similar to the =Spectrum= object, the =rtime= and =intensity= functions to
access the respective data. Below we use the =chromatogram= function to
extract the total ion chromatogram (TIC) for each file and plot it.

#+NAME: chromatogram-tic
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Total ion chromatogram.", fig.width = 10, fig.height = 5
  ## Get chromatographic data (TIC) for an m/z slice
  chr <- chromatogram(data)
  chr

  ## Plot the tic
  plot(chr)
#+END_SRC

The object returned by the =chromatogram= function arranges the individual
=Chromatogram= objects of each file in a two-dimensional array, columns being
samples (files) and rows data slices. Below we extract the (total ion)
intensities from the TIC of the first file.

#+NAME: chromatogram-tic-intensity
#+BEGIN_SRC R :ravel message = FALSE
  ints <- intensity(chr[1, 1])
  head(ints)
#+END_SRC

The object contains also all phenotype information from the original =data=
variable, that can be accessed similarly to the =OnDiskMSnExp= object (or most
other data objects in Bioconductor).

#+NAME: chromatogram-pdata
#+BEGIN_SRC R :ravel message = FALSE
  ## Access the full phenotype data
  pData(chr)
#+END_SRC

Depending on the parameter =aggregationFun=, the function can produce total ion
chromatograms (TIC), with =aggregationFun = "sum"= or base peak chromatograms
(BPC) with =aggregationFun = "max"=. Below we extract and plot the ion
chromatogram for Serine after first filtering the data object to the retention
time and by m/z ranges containing the signal for this compound.

#+NAME: serine-xic
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Extracted ion chromatogram for the Serine [M+H]+ ion in both files."
  ## Extract and plot the XIC for Serine
  data %>%
      filterRt(rt = c(175, 189)) %>%
      filterMz(mz = c(106.02, 106.07)) %>%
      chromatogram(aggregationFun = "max") %>%
      plot()
#+END_SRC 


** Centroiding of profile MS data

MS instruments allow to export data in profile or centroid mode. Profile data
contains the signal for all discrete m/z values (and retention times) for which
the instrument collected data \cite{Smith:2014di}. For each ion at a given
retention time the instrument measures thus multiple intensities, at m/z values
that are distributed around the ion's /real/ m/z value. Centroiding is the process
to reduce these mass peaks to a single representative signal, the
centroid. =xcms=, specifically the /centWave/ chromatographic peak detection
algorithm, was designed for centroided data, thus, prior to data analysis,
profile data should be centroided. The =MSnbase= package provides the basic
toolset to perform centroiding (and data smoothing): =pickPeaks= and =smooth=.

Below we inspect the profile data for the [M+H]+ ion adduct of Serine. We subset
the data to the m/z and retention time range containing signal from Serine and
=plot= the data with =type = "XIC"=, that generates a combined chromatographic and
/map/ visualization of the data (i.e. a plot of the individual m/z, rt and
intensity data tuples with data points colored by their intensity in the m/z -
retention time space).

#+NAME: serine-profile-mode-data
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Profile data for Serine.", fig.width = 10, fig.height = 5, fig.pos = "h!", warning = FALSE
  ## Filter the MS data to the signal from the Serine ion and plot it using
  ## type = "XIC"
  data %>%
      filterRt(rt = c(175, 189)) %>%
      filterMz(mz = c(106.02, 106.07)) %>%
      plot(type = "XIC")
#+END_SRC

The plot shows all data points measured by the instrument. It clearly shows the
mass peaks for Serine, that are represented by a distribution of signal in both
retention time and m/z dimension.

Next we first smooth the data in each spectrum using a Savitzky-Golay filter,
which usually improves data quality by reducing noise, followed by centroiding
the data with a simple peak-picking strategy that reports the maximum signal for
each mass peak in each spectrum.

#+NAME: centroiding
#+BEGIN_SRC R :ravel message = FALSE, warning = FALSE, fig.cap = "Centroided data for Serine.", fig.width = 10, fig.height = 5, fig.pos = "h!", warning = FALSE
  ## Smooth the signal, then do a simple peak picking.
  data_cent <- data %>%
      smooth(method = "SavitzkyGolay", halfWindowSize = 6) %>%
      pickPeaks()

  ## Plot the centroided data for Serine
  data_cent %>%
      filterRt(rt = c(175, 189)) %>%
      filterMz(mz = c(106.02, 106.07)) %>%
      plot(type = "XIC")
#+END_SRC

As expected, centroiding successfully reduced the data to a single data point
for an ion in each spectrum. For more advanced centroiding options that also
fine-tune the m/z value of the reported centroid see the =pickPeaks= help or the
centroiding vignette in =MSnbase=.

Note that, since the MS data is not loaded in memory, smoothing and centroiding
is applied to the data /on-the-fly/ each time that m/z or intensity values are
requested from the data object =data_cent=. To make any data manipulations on an
=OnDiskMSnExp= object /persistent/ we need to export the data. Below we save thus
the centroided data as mzML files and read the exported data again.

#+NAME: export-centroided-prepare
#+BEGIN_SRC R :ravel message = FALSE, echo = FALSE, warnings = FALSE, results = "hide"
  ## Silently removing exported mzML files if they do already exist.
  lapply(basename(fileNames(data)), function (z) {
      if (file.exists(z))
	  file.remove(z)
  })
#+END_SRC

#+NAME: export-centroided
#+BEGIN_SRC R :ravel message = FALSE
  ## Write the centroided data to files with the same names in the current
  ## directory
  fls_new <- basename(fileNames(data))
  writeMSData(data_cent, file = fls_new)

  ## Read the centroided data.
  data_cent <- readMSData(fls_new, pdata = new("NAnnotatedDataFrame", pd),
			  mode = "onDisk")
#+END_SRC

** LC-MS data preprocessing

*** Chromatographic peak detection

Chromatographic peak detection aims to identify peaks along the retention time
axis that represent the signal from individual compounds' ions. This can be
performed with the =findChromPeaks= function that uses different algorithms
depending on the submitted parameter object: with =MatchedFilterParam= it performs
peak detection as described in the original xcms article
\cite{Smith:2006ic}. With =CentWaveParam= a continuous wavelet
transformation-based peak detection is performed that can detect close-by and
partially overlapping peaks with different widths \cite{Tautenhahn:2008fx}. With
=MassifquantParam= it performs a Kalman filter-based peak detection
\cite{Conley:2014ha}. Additional peak detection algorithms for direct injection
data are also available, but not discussed here. 

We use the /centWave/ algorithm that performs peak detection in two steps: first
it identifies regions of interest in the m/z - retention time space and
subsequently detects peaks in these regions using a continuous wavelet transform
(see the original publication for more details). centWave can be configured with
several parameters (see =?CentWaveParam=), with the most important ones being
=peakwidth= and =ppm=. =peakwidth= defines the minimal and maximal expected width (in
retention time dimension) of the peak and depends thus on the LC settings of the
experiment. Appropriate values for this parameter can be defined by looking at
extracted ion chromatograms of known compounds in the data. Below we extract 
chromatographic data for Serine and perform a peak detection on the =Chromatogram=
object using the default parameters for centWave.

#+NAME: centWave-default
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "XIC for Serine", results = "hide"
  ## Get the XIC for serine in the first file
  srn_chr <- chromatogram(data_cent, rt = c(165, 200),
			  mz = c(106.03, 106.06),
			  aggregationFun = "max")[1, 1]
  ## Plot the data
  par(mfrow = c(1, 1), mar = c(4, 4.5, 1, 1))
  plot(srn_chr)

  ## Get default centWave parameters
  cwp <- CentWaveParam()

  ## "dry-run" peak detection on the XIC.
  findChromPeaks(srn_chr, param = cwp)
#+END_SRC

The warning message tells us that centWave did not find any peaks in that
chromatogram. Looking at the default values for the centWave parameters helps
understanding why peak detection fails:

#+NAME: centWave-default-parameters
#+BEGIN_SRC R :ravel message = FALSE
  cwp
#+END_SRC

The default settings for =peakwidth= are 20 to 50 seconds, while the
chromatographic peak for Serine above is about 4 seconds wide. Below we adapt
the settings to accommodate peaks ranging from 2 to 10 seconds and re-run the
peak detection. In general, it is advisable to investigate peak widths for
several ions in the data set to determine the /best/ settings for =peakwidth=.

#+NAME: centWave-adapted
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "XIC for Serine with detected chromatographic peak", results = "hide"
  cwp <- CentWaveParam(peakwidth = c(2, 10))

  pks <- findChromPeaks(srn_chr, param = cwp)

  ## Plot the data and higlight identified peak area
  plot(srn_chr)
  rect(pks[, "rtmin"], 0, pks[, "rtmax"], pks[, "maxo"], border = "#00000040")
#+END_SRC

The next important setting is the =ppm= parameter, that is used in the initial
step of centWave to identify regions of interest. In this step, regions are
defined in which m/z values for an ion do not differ by more than =ppm= in
consecutive spectra. This bases on the assumption that m/z values are more
stable for larger signals. To illustrate this, we plot the full data for Serine.


+ Ideally check settings on more known compounds.
+ =ppm=: maximal allowed scattering of m/z values for one ion.
+ Interactive code: evaluate the m/z scattering of the signal for Serine.

#+NAME: Serine-mz-scattering-plot
#+BEGIN_SRC R :ravel message = FALSE
  ## Restrict the data to signal from Sering
  srn <- data_cent %>%
      filterRt(rt = c(179, 186)) %>%
      filterMz(mz = c(106.04, 106.06))

  ## Plot the data
  plot(srn, type = "XIC")
#+END_SRC

Indeed higher intensity signals tend to scatter less in m/z dimension. We next
calculate for this data subset the difference in m/z values between consecutive
scans.

#+NAME: define-ppm
#+BEGIN_SRC R :ravel message = FALSE
  ## Extract the Serine data for one file as a data.frame
  srn_df <- as(filterFile(srn, 1), "data.frame")

  ## The difference between m/z values from consecutive scans expressed
  ## in ppm
  diff(srn_df$mz) * 1e6 / mean(srn_df$mz)
#+END_SRC

The difference in m/z values for the Serine data is between 0 and 27
ppm. Ideally this should be evaluated for several compounds and should be set to
a value that allows to capture the full chromatographic peaks for most of the
tested compounds. We can next perform the peak detection based on our settings.

#+NAME: findPeaks-centWave
#+BEGIN_SRC R :ravel message = FALSE
  ## Perform peak detection
  cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 30)
  data_cent <- findChromPeaks(data_cent, param = cwp)
#+END_SRC

The result from the =findChromPeaks= call is an =XCMSnExp= object which contains all
preprocessing results and, by extending the =OnDiskMSnExp= object, inherits all of
the functionality described so far. The results from the peak detection analysis
can be accessed with the =chromPeaks= function, that, with the optional =rt= and =mz=
parameters, allows to extract identified chromatographic peaks from specific
areas in the data.

#+NAME: xcmsnexp
#+BEGIN_SRC R :ravel message = FALSE, results = "hide"
  ## Access the peak detection results from a specific m/z - rt area
  chromPeaks(data_cent, mz = c(106, 107), rt = c(150, 190))
#+END_SRC

For each identified peak the m/z value of the apex is reported (column "mz"),
the m/z range ("mzmin", "mzmax"), the retention time of the apex ("rt") and its
range ("rtmin", "rtmax"), the integrated signal of the peak (i.e. the peak area
"into"), the maximal signal of the peak ("maxo"), the signal to noise ratio
("sn") and the index of the sample in which the peak was detected ("sample").
For quality assessment we could now calculate summary statistics on the
identified peaks to e.g. identify samples with much less detected peaks. Also,
we can use the =plotChromPeaks= function to provide some general information on
the location of the identified chromatographic peaks in the m/z - rt space.

#+NAME: plotChromPeaks
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Location of the identified chromatographic peaks in the m/z - rt space."
  par(mfrow = c(1, 2))
  plotChromPeaks(data_cent, 1)
  plotChromPeaks(data_cent, 2)
#+END_SRC

*** Alignment

+ Aim: adjusts shifts in retention times between samples.
+ Interactive code: plot the base peak chromatograms of all files.
#+NAME: alignment-bpc-raw
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "BPC of all files", fig.width = 8, fig.height = 4
  ## Extract base peak chromatograms
  bpc_raw <- chromatogram(data_cent, aggregationFun = "max")
  par(mfrow = c(1, 1))
  plot(bpc_raw)
#+END_SRC

+ Function: =adjustRtime=.
+ Available methods:
  - /peakGroups/ (=PeakGroupsParam=) \cite{Smith:2006ic}: align samples based on
    hook peaks.
  - /obiwarp/ (=ObiwarpParam=) \cite{Prince:2006jj}: warps the (full) data to a
    reference sample.

+ peakGroups works reasonably well in most cases.
+ Need to define the hook peaks first: peaks present in most/all samples.
+ Important parameters:
  - =minFraction=: proportion of samples in which a feature has to be present (0.9
    for present in 90% of samples).
  - =span=: degree of smoothing for the loess function, 0 likely overfitting, 1
    linear regression. Values between 0.4 and 0.6 seem reasonable.
+ Interactive code: perform a peak grouping to define potential hook peaks and
  align the samples based on these.
#+NAME: alignment-correspondence
#+BEGIN_SRC R :ravel message = FALSE
  ## Define the settings for the initial peak grouping - details for
  ## choices in the next section.
  pdp <- PeakDensityParam(sampleGroups = data_cent$group, bw = 1.8,
			  minFraction = 1, binSize = 0.02)
  data_cent <- groupChromPeaks(data_cent, pdp)

  ## Define settings for the alignment
  pgp <- PeakGroupsParam(minFraction = 1, span = 0.6)
  data_cent <- adjustRtime(data_cent, param = pgp)
#+END_SRC

+ Adjusted retention times are stored in the object.
+ Interactive code: inspect the difference between raw and adjusted retention
  times. Helps to determine whether settings were OK.
#+NAME: alignment-result
#+BEGIN_SRC R :ravel message = FALSE, fig.width = 8, fig.height = 4
  ## Plot the difference between raw and adjusted retention times
  plotAdjustedRtime(data_cent)
#+END_SRC

+ Evaluate alignment results:
  - difference between raw and adjusted retention time reasonable.
  - hook peaks along the full retention time range.
  - comparison of BPC (TIC) before/after alignment.
  - evaluate data for known compounds.
+ Interactive code: plot BPC before and after alignment.

#+NAME: bpc-raw-adjusted
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "BPC before (top) and after (bottom) alignment.", fig.width = 10, fig.height = 8
  par(mfrow = c(2, 1))
  ## Plot the raw base peak chromatogram
  plot(bpc_raw)
  ## Plot the BPC after alignment
  plot(chromatogram(data_cent, aggregationFun = "max"))
#+END_SRC

+ Interactive code: plot Serine XIC before and after alignment.

#+NAME: serine-xic-adjusted
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "XIC for Serine before (left) and after (right) alignment", fig.width = 10, fig.height = 4
  ## Use adjustedRtime parameter to access raw/adjusted retention times
  par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
  plot(chromatogram(data_cent, mz = c(106.04, 106.06),
		    rt = c(179, 186), adjustedRtime = FALSE))
  plot(chromatogram(data_cent, mz = c(106.04, 106.06),
		    rt = c(179, 186)))
#+END_SRC

+ If we need to repeat simply remove alignment results with =dropAdjustedRtime=
  and retry.

*** Correspondence

+ Aim: group signal (peaks) from the same ion across samples.
+ Function: =groupChromPeaks=.
+ Methods available:
  - /peak density/ (=PeakDensityParam=) \cite{Smith:2006ic}.
  - /nearest/ (=NearestPeaksParam=) \cite{Katajamaa:2006jh}.

+ peak density: 
  - iterates through slices of m/z ranges and groups chromatographic in each if
    peaks (from same or different samples) are close in retention time.
  - whether they are close is estimated on the distribution of peaks along the
    retention time.
+ Interactive code: plot the data for the m/z slice containing the Serine peak
  and dry-run a correspondence analysis.

#+NAME: correspondence-example
#+BEGIN_SRC R :ravel message = FALSE, results = "hide", fig.cap = "BPC for a m/z slice and defined features within this slice based on default settings." 
  ## Plot the BPC for the m/z slice containing serine
  par(mfrow = c(2, 1), mar = c(4, 4.3, 1, 0.5))
  plot(chromatogram(data_cent, mz = c(106.04, 106.06), aggregationFun = "max"))
  highlightChromPeaks(data_cent, mz = c(106.04, 106.06),
		      whichPeaks = "apex_within")

  ## Get default parameters for the grouping
  pdp <- PeakDensityParam(sampleGroups = data_cent$group)
  pdp

  ## Dry-run correspondence and show the results.
  plotChromPeakDensity(data_cent, mz = c(106.04, 106.06),
		       type = "apex_within", param = pdp)

#+END_SRC

+ Black line shows the peak density estimate, points represent the position of
  peaks along the retention time axis per sample and grey rectangles indicate
  grouped peaks (features).
+ Parameters:
  - =binSize=: m/z width of the bin/slice of data in which peaks are grouped.
  - =bw= defines the smoothness of the density function.
  - =maxFeatures=: maximum number of features to be defined in one bin.
  - =minFraction=: minimum proportion of samples (of one group!) for which a peak
    has to be present.
  - =minSamples=: minimum number of samples a peak has to be present.
+ Parameters =minFraction= and =minSamples= depend on experimental layout!
+ =binSize= should be small enough that peaks from different ions measured at the
  same retention time would not be grouped together.
+ Interactive code: determine acceptable =bw= setting. Plot data for ions with
  same m/z and similar retention time: isomers Betaine and Valine ([M+H]+ m/z
  118.08625).

#+NAME: correspondence-bw
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Define correspondence settings to separate Methylhistidine peaks.", fig.width = 10, fig.height = 10
  par(mfrow = c(3, 1), mar = c(3, 4.3, 1, 1))

  ## Plot the chromatogram for an m/z slice containing Betaine and Valine
  mzr <- 118.08625 + c(-0.01, 0.01)
  plot(chromatogram(data_cent, mz = mzr, aggregationFun = "max"))
  highlightChromPeaks(data_cent, mz = mzr, whichPeaks = "apex_within")

  ## Correspondence in that slice using default settings
  pdp <- PeakDensityParam(sampleGroups = data_cent$group)
  plotChromPeakDensity(data_cent, mz = mzr, param = pdp, type = "apex_within")

  ## Reducing the bandwidth
  pdp <- PeakDensityParam(sampleGroups = data_cent$group, bw = 1.8)
  plotChromPeakDensity(data_cent, mz = mzr, param = pdp, type = "apex_within")
#+END_SRC

+ Reducing the =bw= enables grouping of isomer peaks into different
  features.
+ Interactive code: perform the correspondence analysis.

#+NAME: correspondence-analysis
#+BEGIN_SRC R :ravel message = FALSE
  pdp <- PeakDensityParam(sampleGroups = data_cent$group, bw = 1.8,
			  minFraction = 0.4, binSize = 0.02)

  ## Perform the correspondence analysis
  data_cent <- groupChromPeaks(data_cent, param = pdp)
#+END_SRC

+ Evaluate results after correspondence: check for another slice with isomers:
  Leucine, Isoleucine ([M+H]+ m/z 132.10191). Setting =simulate = FALSE= shows the
  actual grouping results.

#+NAME: correspondence-evaluate
#+BEGIN_SRC R :ravel message = FALSE, fig.cap = "Result of correspondence on a slice containing the isomers Leucine and Isoleucine.", fig.width = 10, fig.heigt = 8
  par(mfrow = c(2, 1), mar = c(3, 4.3, 1, 1))

  ## Plot the chromatogram for an m/z slice containing Leucine and Isoleucine
  mzr <- 132.10191 + c(-0.01, 0.01)
  plot(chromatogram(data_cent, mz = mzr, aggregationFun = "max"))
  highlightChromPeaks(data_cent, mz = mzr, whichPeaks = "apex_within")

  plotChromPeakDensity(data_cent, mz = mzr, param = pdp, type = "apex_within",
		       simulate = FALSE)
#+END_SRC

+ Interactive code: inspect result object and extract feature intensities.

#+NAME: correspondence-result-object
#+BEGIN_SRC R :ravel message = FALSE
  ## Get general information
  data_cent

  ## Overview of the performed processings
  processHistory(data_cent)

  ## Access the parameter class for a processing step
  processParam(processHistory(data_cent)[[1]])
#+END_SRC

+ Interactive code: inspect definition of features and extract feature
intensities.

#+NAME: correspondence-feature-values
#+BEGIN_SRC R :ravel message = FALSE
  ## Definition of the features
  featureDefinitions(data_cent)

  ## Per-feature summary.
  head(featureSummary(data_cent))

  ## feature intensity matrix
  fmat <- featureValues(data_cent, value = "into", method = "maxint")
  head(fmat)
#+END_SRC

+ =featureValues= parameters:
  - =value=: name of the column in =chromPeaks= that should be returned.
  - =method=: for features with multiple peaks in one sample: from which peak the
    should the value be returned?

+ About missing values: peak detection may have failed. =fillChromPeaks= allows to
  fill in signal for missing peaks from the feature area (defined by the median
  rt and mz of all peaks assigned to the feature).
  Parameters:
  - =expandMz=: expands the region from which signal is integrated in m/z
    dimension. A value of 0 means no expansion, 1 means the region is grown by
    half of the feature's m/z width on both sides.
  - =expandRt=: expand the retention time window of the feature for integration.
  - =ppm=: expand the m/z width by a m/z dependent value.
+ Interactive code: evaluate the number of missing peaks and use =fillChromPeaks=
  to retrieve a signal for them from the raw files.

#+NAME: fillChromPeaks
#+BEGIN_SRC R :ravel message = FALSE
  ## Number of missing values
  sum(is.na(fmat))

  ## Define the settings for the fill-in of missing peaks
  fpp <- FillChromPeaksParam(expandMz = 0.5, expandRt = 0.5, ppm = 20)
  data_cent <- fillChromPeaks(data_cent, param = fpp)

  ## How many missing values after
  sum(is.na(featureValues(data_cent)))

  fmat_fld <- featureValues(data_cent, value = "into", method = "maxint")
  head(fmat_fld)
#+END_SRC

+ Note: =dropFilledChromPeaks= removes filled-in peaks again.

* Summary

+ Don't blindly use default parameters!
+ The new data objects and functions are aimed to simplify data access and
  inspection of results and should facilitate data set-dependent definition of
  algorithm parameters.
+ More work to come for the analysis of chromatographic data (SRM/MRM).

* References






